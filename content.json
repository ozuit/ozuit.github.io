{"pages":[],"posts":[{"title":"6 bước để tối ưu ứng dụng React Native của bạn","text":"Theo thống kê từ Google có khoảng 53% người dùng sẽ rời khỏi ứng dụng di động nếu mất hơn 3 giây để tải. Điều này có nghĩa là với mỗi giây ứng dụng của bạn tải thất bại thì bạn sẽ mất đi một lượng khách hàng tiềm năng. Trong bài viết này, chúng ta sẽ thảo luận về các phương pháp để tối ưu hiệu suất hoạt động của ứng dụng di động được viết bằng React Native. 1. Sử dụng shouldComponentUpdate hoặc PureComponentĐối với các component thông thường, trong một vài trường hợp chúng ta không muốn bị render lại thì việc sử dụng phương thức shouldComponentUpdate sẽ là một giải pháp hiệu quả giúp bạn xử lý vấn đề này bằng cách cho giá trị trả về của phương thức này bằng false sẽ ngăn component render lại.PureComponent hoàn toàn tương tự với Component thông thường ngoài trừ việc nó sẽ xử lý shouldComponentUpdate giúp bạn. 123456789101112131415class MyComponent extends React.Component { // ... shouldComponentUpdate(nextProps, nextState) { if(this.props.firstProp === nextProps. firstProp &amp;&amp; this.props.secondProp === nextProps.secondProp) { return false; } return true } // ...}class MyComponent extends React.PureComponent { // ...} 2. Sử dụng thuộc tính key cho mỗi mục trong danh sách được renderDanh sách là thứ được sử dụng thường xuyên nhất trong mọi ứng dụng. Nếu bạn không đặt thuộc tính key cho mỗi mục trong danh sách thì React sẽ render lại toàn bộ các mục trong danh sách khi có bất kỳ một mục nào được thêm vào hoặc xoá ra khỏi danh sách. Khi có thuộc tính key thì react sẽ hạn chế render lại toàn bộ danh sách mà chỉ render lại những mục thay đổi. 1234567class MyComponent extends React.PureComponent { render() { return this.props.data.map((item, i) =&gt; { return &lt;Text key={item.id}&gt;{item.title}&lt;/Text&gt; }); }} 3. Thực hiện bind trong constructor và không tạo hàm trong renderLàm điều này: 12345678910111213141516class MyComponent extends React.PureComponent { constructor(props) { super(props); this.doWork = this.doWork.bind(this); } doWork() { // doing some work here. // this.props.dispatch.... } render() { return &lt;Text onPress={this.doWork}&gt;Do Some Work&lt;/Text&gt; } } Đừng làm điều này trong render: 1&lt;Text onPress={ () =&gt; this.doWork() }&gt;Do Some Work&lt;/Text&gt; hoặc 1&lt;Text onPress={ this.doWork.bind(this) }&gt;Do Some Work&lt;/Text&gt; Bởi vì như vậy hàm render sẽ được gọi rất thường xuyên và mỗi lần bạn viết như 2 cách trên thì một hàm mới sẽ được tạo ra.Nếu bạn muốn truyền tham số vào hàm doWork, bạn có thể cần phải tạo một component con và truyền hàm vào như một prop. 1&lt;child arg1={arg1}&gt;&lt;/child&gt; Và trong component con sẽ viết như sau: 123456doWork() { console.log(this.props.arg1);}render() { return &lt;Text onPress={this.doWork}&gt;Do Some Work&lt;/Text&gt;} Nếu bạn đang tạo một component ở trên cùng thì cần phải đánh đổi một ít hiệu suất nhưng code sẽ dễ đọc hơn bằng cách sử dụng closure như bên dưới. Một hàm mới sẽ được tạo ra mỗi khi render lại. 1234doWork = (param) =&gt; () =&gt; { console.log(param)}&lt;Text onPress={this.doWork(someVarParam)}&gt;Do Some Work With Args&lt;/Text&gt; Vì vậy bạn cần cân nhắc giữa khả năng đọc code và yêu cầu hiệu suất trong những trường hợp như vậy. 4. Đừng cập nhật state hoặc dispatch actions trong componentWillUpdatePhương thức componentWillUpdate được sử dụng để chuẩn bị cho một sự thay đổi, không dùng để kích hoạt một đối tượng khác. Nếu bạn muốn setState hoặc dispatch bất kỳ redux actions nào hãy thực hiện nó trong componentWillReceiveProps. 5. Sử dụng VirtualizedList, FlatList và SectionList cho một tập dữ liệu lớnTheo tài liệu từ React Native thì VirtualizedList, FlatList và SectionList cho hiệu suất cao hơn khi render list. Nếu bạn có một danh sách với hàng trăm dòng thì các dòng đó sẽ chỉ được hiển thị trên màn hình khi bạn cuộn xuống.VirtualizedList dựa trên cả FlatList và SectionList nên nếu bạn có một tập dữ liệu bất biến thì bạn nên sử dụng trực tiếp VirtualizedList. 6. Sử dụng Perf monitor để theo dõi FPSHãy vào developer tool và mở perf monitor lên. Bây giờ khi bạn bắt đầu tương tác, điều hướng hoặc cuộn lên/xuống ứng dụng của bạn, bạn có thể nhìn thấy FPT bị suy giảm. Chủ yếu sự suy giảm này đến từ JS Thread chứ không từ native UI Thread. Vì vậy ta có thể tìm các điểm chết nơi FPT bị giảm, bạn có thể đã setState hoặc dispatch redux actions sai ở một vài chỗ hoặc thực hiện qúa nhiều công việc bất đồng bộ trên JS Thread.","link":"/React-Native/2020-06-30-6-ways-to-optimal-your-react-native-app/"},{"title":"Tự tạo chatbot bán hàng với Dialogflow - Phần 1","text":"Dialogflow là cái gì ?Dialogflow là một dịch vụ do Google cung cấp nhằm giúp các lập trình viên có thể dễ dàng hơn trong việc lập trình ra các sản phẩm có giao tiếp với người dùng thông qua các đoạn hội thoại. Dialogflow sử dụng trí tuệ nhân tạo (AI) giúp phân tích ngôn ngữ tự nhiên để hiểu được ý định của người dùng và trích xuất ra các thông tin hữu ích phù hợp với ý định của người dùng. Có vẻ vẫn còn khá là mơ hồ nhỉ, vậy chúng ta hãy cùng xem qua ví dụ này nhé! Đó là thứ mà Dialogflow có thể làm cho bạn, nó sẽ giúp bạn tạo ra một trợ lý ảo thật sự để thay bạn tư vấn và trả lời các thắc mắc của khách hàng khi họ truy cập vào website của bạn. Đây không chỉ đơn thuần là một chatbot thông thường mà nó có khả năng đọc hiểu ngôn ngữ tự nhiên vì vậy khách hàng có thể hỏi bằng nhiều cách khác nhau nhưng nó đều sẽ hiểu và trả lời lại đúng theo kịch bản mà bạn đã thiết lập. Khởi tạo dự ánĐầu tiên bạn cần truy cập vào địa chỉ https://dialogflow.cloud.google.com và đăng nhập vào bằng tài khoản gmail của mình. Tiếp theo chọn quốc gia Vietnam và đồng ý điều khoản của Google. Cuối cùng nhấn vào nút Create Agent để tạo mới một trợ lý ảo cho riêng bạn nào. Nếu bạn vẫn chưa đăng ký được một trợ lý ảo cho riêng mình thì hãy xem video hướng dẫn bên dưới nhé!Ở phần tiếp theo chúng ta sẽ tìm hiểu rõ hơn về các thành phần cấu tạo nên một trợ lý ảo (chatbot) trong Dialogflow thông qua ví dụ cụ thể như hình trên.","link":"/AI/2020-04-08-build-chat-bot-with-dialogflow-part-1/"},{"title":"Tự tạo chatbot bán hàng với Dialogflow - Phần 3 (Tạo các Intents con)","text":"Để chat bot có thể ghi nhớ được thông tin từ các câu trả lời trước của người dùng ta cần định nghĩa thêm các Intent con, khi đó thông tin từ Intent cha sẽ được truyền xuống cho Intent con và chat bot có thể dựa vào đó để đưa ra các câu hỏi tương ứng tiếp thi. Ở phần trước chúng ta đã tạo ra một Intent tên là iTuVan để xử lý yêu cầu của người dùng khi cần tư vấn về sữa, chat bot sẽ đưa ra các câu hỏi gợi mở như “bạn cần mua loại nào: Frisolac Gold, Nan Nestle, Physiolac, Morinaga, Meiji”. Khi người dùng trả lời tên một loại sữa (VD: frisolac) thì chat bot sẽ hỏi tiếp “bạn muốn hỏi về giá hay chỗ mua sữa Frisolac Gold?” để làm được như vậy ta cần tạo thêm một Intent con từ Itent iTuVan bằng cách chọn vào Add follow-up intent tại giao diện quản lý danh sách các Intents, tiếp tục chọn custom từ menu xổ xuống và ta đặt tên cho Intent con này là “iTuVan - Frisolac Gold”. iTuVan - Frisolac Gold Training phrases: mình cần hỏi sữa Frisolac sữa Frisolac á bạn Responses: bạn muốn hỏi về giá hay chỗ mua sữa Frisolac Gold? Tiếp theo ta cần tạo ra tiếp 2 Intent con của “iTuVan - Frisolac Gold” nhiệm vụ của 2 Intent con này là để tư vấn về giá và chỗ mua, cách tạo ta cũng làm tương tự như tạo Itent “iTuVan - Frisolac Gold” sau đó đặt tên cho 2 Intent này lần lượt là “iTuVan - Frisolac Gold - Gia” và “iTuVan - Frisolac Gold - Dia chi”. iTuVan - Frisolac Gold - Gia Training phrases: giá bao nhiêu nhỉ bao nhiêu tiền 1 hộp Responses: dạ giá 1 hộp sữa Frisolac Gold 900g là 499k ạ iTuVan - Frisolac Gold - Dia chi Training phrases: bán ở đâu vậy? chỗ nào bán vậy bạn? Responses: dạ sữa Frisolac Gold đang được bán ở các siêu thị trên cả nước ạ Như vậy là ta đã làm xong cho nhánh thứ nhất về sữa “frisolac”, tương tự các bạn có thể tạo ra các Intent cho các loại sữa khác. Kết thúc phần này chúng ta đã cùng nhau tìm hiểu xong về khái niệm Intent và vận dụng nó vào một ví dụ cụ thể, ở phần tiếp theo tôi sẽ tiếp tục nói về một thành phần quan trọng khác trong Dialogflow đó chính là Entity đây chính là thứ giúp cho chat bot của chúng ta có thể nhận biết được ý định của người dùng để từ đó có thể đưa ra các câu trả lời phù hợp theo từng Intent mà chúng ta đã định nghĩa.","link":"/AI/2020-04-23-build-chat-bot-with-dialogflow-part-3/"},{"title":"Build voice assistant with React Native and Gemini AI","text":"In this tutorial, we are going to find out step by step how to build an assistant that you can chat face to face via text or voice message. Using React Native and one of the most popular language models today is Gemini AI. Prerequisites: Node.js and npm: Ensure that Node.js and npm are installed on your machine. Otherwise, you can follow here downloading-and-installing-node-js-and-npm Code editor: You can use any editor you love but in this tutorial, I use Visual Studio Code Gemini AI key: Obtain your Gemini AI key by signing up at https://ai.google.dev/ Create a new React Native projectLet’s begin by creating a new project with React Native using the following command: 1npx react-native init ReactNativeVoiceAssistant To set up your environment, run, and build a React Native project, you can follow the instructions outlined in the React Native Get Started guide. Installing dependenciesNext, we will install some packages for this project. Run the following commands one after another: 123456789101112131415161718192021222324// for interaction with Rest APInpm install axios// speech to textnpm install @react-native-voice/voice// react native navigationnpm install @react-navigation/nativenpm install react-native-screensnpm install react-native-safe-area-contextnpm install @react-navigation/native-stack// text to speechnpm install --save react-native-tts// chat componentnpm install react-native-gifted-chat// vector iconsnpm install --save react-native-vector-iconsnpm install @types/react-native-vector-icons// environment variablenpm install -D react-native-dotenv I will not explain this detail here, you can find more documentation on their official sites. ImplementingCreating folders structureIn the root, create some folders: src/screens, src/navigations, src/services and src/styles. The screens folder contain all code related to Welcome Screen and ChatScreen, navigations folder for code related to navigation between screens, services folder for code related to logic accessing the rest API, styles for stylesheets. Creating service for accessing the Gemini AI rest APIFirst, create a .env file in the root folder and store your API key here. Please remember not to publish your API key. 12API_KEY=YourApiKeyHereAPI_URL=https://generativelanguage.googleapis.com/v1beta/models/gemini-1.0-pro:generateContent Next, create the file src/services/AiService.js. The following code will read variables from .env and call the rest API via Axios. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import { API_KEY, API_URL } from \"@env\";import axios from \"axios\";export const getAnswerFromGpt = async (prompts) =&gt; { console.log(prompts); try { const client = axios.create({ headers: { \"Content-Type\": \"application/json\", }, }); const response = await client.post(`${API_URL}?key=${API_KEY}`, { contents: prompts, generationConfig: { temperature: 0.9, topK: 1, topP: 1, maxOutputTokens: 2048, stopSequences: [], }, safetySettings: [ { category: \"HARM_CATEGORY_HARASSMENT\", threshold: \"BLOCK_MEDIUM_AND_ABOVE\", }, { category: \"HARM_CATEGORY_HATE_SPEECH\", threshold: \"BLOCK_MEDIUM_AND_ABOVE\", }, { category: \"HARM_CATEGORY_SEXUALLY_EXPLICIT\", threshold: \"BLOCK_MEDIUM_AND_ABOVE\", }, { category: \"HARM_CATEGORY_DANGEROUS_CONTENT\", threshold: \"BLOCK_MEDIUM_AND_ABOVE\", }, ], }); const answer = response.data?.candidates[0]?.content?.parts?.[0]?.text; return Promise.resolve({ success: true, data: answer }); } catch (error) { return Promise.resolve({ success: false, msg: error.message }); }}; Creating WelcomeScreenWe need to create a src/screens/WelcomeScreen.tsx file for logic code and a src/styles/WelcomeStyle.ts file for the stylesheet. 1234567891011121314151617181920212223242526272829303132333435// Import necessary components and librariesimport { NavigationProp, ParamListBase, useNavigation } from '@react-navigation/native';import React from 'react';import { Text, TouchableOpacity, View } from 'react-native';import { SafeAreaView } from 'react-native-safe-area-context';import MaterialCommunityIcons from 'react-native-vector-icons/MaterialCommunityIcons';import { styles } from '../styles/WelcomeStyle';const WelcomeScreen = () =&gt; { const navigation = useNavigation&lt;NavigationProp&lt;ParamListBase&gt;&gt;(); const handleNext = () =&gt; { navigation.navigate('ChatScreen'); }; return ( &lt;SafeAreaView style={styles.container}&gt; &lt;View style={styles.container}&gt; &lt;View&gt; &lt;Text style={styles.title}&gt;React Native Voice Assistant&lt;/Text&gt; &lt;Text style={styles.subtitle}&gt;With Voice Command powered by OpenAI&lt;/Text&gt; &lt;/View&gt; &lt;MaterialCommunityIcons name=\"account-tie-voice\" size={200} style={{ marginBottom: 10, marginRight: 10, color: '#10a37f' }} /&gt; &lt;TouchableOpacity style={styles.button} onPress={handleNext}&gt; &lt;Text style={styles.buttonText}&gt;Start Chat&lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; &lt;/SafeAreaView&gt; );};export default WelcomeScreen; 12345678910111213141516171819202122232425262728293031323334import { StyleSheet } from \"react-native\";// Stylesconst styles = StyleSheet.create({ container: { flex: 1, justifyContent: \"space-between\", alignItems: \"center\", padding: 38, }, title: { fontSize: 24, fontWeight: \"bold\", textAlign: \"center\", color: \"#10a37f\", }, subtitle: { fontSize: 12, color: \"#666\", textAlign: \"center\", }, button: { backgroundColor: \"#10a37f\", paddingVertical: 5, paddingHorizontal: 20, borderRadius: 20, }, buttonText: { color: \"#FFF\", fontSize: 18, },});export { styles }; Creating ChatScreenWe also create two files the same as WelcomeScreen. Put the following code to src/screens/ChatScreen.tsx file: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219// Import necessary components and librariesimport Voice from '@react-native-voice/voice';import React, { useEffect, useRef, useState } from 'react';import { Platform, SafeAreaView, TouchableOpacity, View } from 'react-native';import { GiftedChat, IMessage, Send } from 'react-native-gifted-chat';import Tts from 'react-native-tts';import MaterialCommunityIcons from 'react-native-vector-icons/MaterialCommunityIcons';import { getAnswerFromGpt } from '../services/OpenAiService';import { styles } from '../styles/ChatStyle';const initialMessages: IMessage[] = [ { _id: 1, text: 'Hi there! How can I assist you today?', createdAt: new Date(), system: true, user: { _id: 1 }, },];const ChatScreen = () =&gt; { const [recording, setRecording] = useState(false); const [messages, setMessages] = useState(initialMessages); const [result, setResult] = useState(''); const listPrompt = useRef&lt;any&gt;([]); const onSend = (messages: IMessage[] = []) =&gt; { const { text } = messages[0]; setMessages(previousMessages =&gt; { return GiftedChat.append(previousMessages, messages, Platform.OS !== 'web'); }); processTranscription(text); }; useEffect(() =&gt; { Tts.setDefaultLanguage('en_US'); }, []); useEffect(() =&gt; { Voice.onSpeechStart = () =&gt; { console.log('===speech start'); setRecording(true); }; Voice.onSpeechEnd = () =&gt; { console.log('===speech end'); setRecording(false); }; Voice.onSpeechError = (e: any) =&gt; { const errMsg: string = e.error?.message; if (errMsg.includes('No match')) { console.log('You are not speaking!'); } else { console.log(errMsg); } setRecording(false); }; Voice.onSpeechResults = (e: any) =&gt; { const prompt = e.value[0]; if (!prompt) { return; } setResult(prompt); }; setMessages(initialMessages); return () =&gt; { Voice.destroy().then(Voice.removeAllListeners); Tts.stop(); }; }, []); const stopRecording = async () =&gt; { try { await Voice.stop(); setRecording(false); console.log('== stopRecording'); if (result) { const newMsg = { _id: Math.round(Math.random() * 1000000), text: result, createdAt: new Date(), user: { _id: 2, name: 'User', }, }; const newMessage = [newMsg]; setMessages(previousMessages =&gt; { return GiftedChat.append(previousMessages, newMessage, Platform.OS !== 'web'); }); processTranscription(result); } } catch (error: any) { console.log('== eror when stop: ', error); } }; const startRecording = async () =&gt; { console.log('== startRecording '); setRecording(true); Tts.stop(); try { await Voice.start('en_US'); } catch (e) { console.error(e); } }; const readTheAnswer = (message: string) =&gt; { console.log('tts: ', message); Tts.speak(message); }; const processTranscription = async (prompt: string) =&gt; { if (prompt.trim().length &gt; 0) { console.log('stt: ', prompt.trim()); listPrompt.current = [ ...listPrompt.current, { role: 'user', parts: [ { text: prompt.trim(), }, ], }, ]; getAnswerFromGpt(listPrompt.current).then((res: any) =&gt; { if (res.success) { const newMsg = { _id: Math.round(Math.random() * 1000000), text: res.data, createdAt: new Date(), user: { _id: 1, name: 'Assistant', }, }; const newMessage = [newMsg]; setMessages(previousMessages =&gt; { return GiftedChat.append(previousMessages, newMessage, Platform.OS !== 'web'); }); if (res.data) { listPrompt.current = [ ...listPrompt.current, { role: 'model', parts: [ { text: res.data.trim(), }, ], }, ]; readTheAnswer(res.data); } } else { console.log(res.msg); } }); } }; const renderSend = (props: any) =&gt; { return ( &lt;&gt; &lt;Send {...props}&gt; &lt;MaterialCommunityIcons name=\"send\" style={styles.buttonSend} /&gt; &lt;/Send&gt; &lt;TouchableOpacity style={styles.buttonMicStyle} onPress={recording ? stopRecording : startRecording}&gt; {recording ? ( &lt;MaterialCommunityIcons name=\"stop\" style={styles.buttonRecordingOff} /&gt; ) : ( &lt;MaterialCommunityIcons name=\"microphone\" style={styles.buttonRecordingOn} /&gt; )} &lt;/TouchableOpacity&gt; &lt;/&gt; ); }; const scrollToBottomComponent = () =&gt; { return &lt;MaterialCommunityIcons name=\"arrow-down-circle-outline\" size={38} color=\"#10a37f\" /&gt;; }; return ( &lt;SafeAreaView style={styles.container}&gt; &lt;View style={styles.container}&gt; &lt;GiftedChat messages={messages} showAvatarForEveryMessage={true} onSend={messages =&gt; onSend(messages)} user={{ _id: 2, name: 'User', avatar: '', }} alwaysShowSend renderSend={renderSend} scrollToBottom scrollToBottomComponent={scrollToBottomComponent} /&gt; &lt;/View&gt; &lt;/SafeAreaView&gt; );};export default ChatScreen; This code put into src/styles/ChatStyle.ts 12345678910111213141516171819202122import { StyleSheet } from \"react-native\";const styles = StyleSheet.create({ container: { flex: 1, }, buttonSend: { fontSize: 20, marginBottom: 12, marginRight: 10, }, buttonMicStyle: { alignItems: \"center\", justifyContent: \"center\", alignSelf: \"center\", marginRight: 10, }, buttonRecordingOff: { fontSize: 25 }, buttonRecordingOn: { fontSize: 25 },});export { styles }; Creating navigationCreate a src/navigations/AppNavigation.tsx file to handle navigation between screens in the application. 12345678910111213141516171819202122232425262728293031323334353637import { NavigationContainer } from \"@react-navigation/native\";import { createNativeStackNavigator } from \"@react-navigation/native-stack\";import React from \"react\";import ChatScreen from \"../screens/ChatScreen\";import WelcomeScreen from \"../screens/WelcomeScreen\";const Stack = createNativeStackNavigator();const AppNavigation = () =&gt; { return ( &lt;NavigationContainer&gt; &lt;Stack.Navigator initialRouteName=\"WelcomeScreen\"&gt; &lt;Stack.Screen name=\"WelcomeScreen\" component={WelcomeScreen} options={{ headerShown: false }} /&gt; &lt;Stack.Screen name=\"ChatScreen\" component={ChatScreen} options={{ title: \"Voice Assistant\", headerStyle: { backgroundColor: \"#d8d8d8\", }, headerTintColor: \"black\", headerTitleStyle: { fontWeight: \"bold\", }, }} /&gt; &lt;/Stack.Navigator&gt; &lt;/NavigationContainer&gt; );};export default AppNavigation; Next, we include the AppNavigation component in App.tsx file by replacing content with the following code. 123456789101112131415import React from \"react\";import { LogBox } from \"react-native\";import { SafeAreaProvider } from \"react-native-safe-area-context\";import AppNavigation from \"./src/navigations/AppNavigation\";LogBox.ignoreLogs([\"Warning: ...\"]); // Ignore log notification by messageLogBox.ignoreAllLogs(); //Ignore all log notificationsexport default function App() { return ( &lt;SafeAreaProvider&gt; &lt;AppNavigation /&gt; &lt;/SafeAreaProvider&gt; );} Run your applicationRun on ios: 1npx react-native run-ios Run on android: 1npx react-native run-android Demo: https://www.upload-apk.com/MNOcITAysahht00","link":"/React-Native/2024-03-14-build-voice-assistant-with-react-native-and-gemini-ai/"},{"title":"Tự tạo chatbot bán hàng với Dialogflow - Phần 5 (Tích hợp vào website)","text":"Trong các phần trước tôi đã hướng dẫn các bạn tạo ra một chat bot cho riêng mình và chúng ta đã cùng nhau tạo ra môt chat bot cho ví dụ tư vấn về sữa bột cho trẻ em. Trong phần này tôi sẽ hướng dẫn các bạn cách tích hợp chat bot của mình vào website một cách dễ dàng. Đầu tiên các bạn chọn vào mục Integratuons trong menu bên phải sau đó kích hoạt Dialogflow Messenger trong phần Text based, tiếp theo các bạn chỉ cần copy đoạn code được tạo ra sẵn giống như bên dưới vào website của bạn nơi mà bạn muốn hiển thị chat bot của mình lên. 1234567&lt;script src=\"https://www.gstatic.com/dialogflow-console/fast/messenger/bootstrap.js?v=1\"&gt;&lt;/script&gt;&lt;df-messenger chat-icon=\"https://cdn.onlinewebfonts.com/svg/img_382824.png\" chat-title=\"BabyShop\" agent-id=\"54da5741-13a0-402e-b25a-c2408e79afa3\" language-code=\"en\"&gt;&lt;/df-messenger&gt;\u001c Mặc định thì chat bot của chúng ta sẽ lấy theo tên của Agent được tạo ra trong Dialogflow, các bạn có thể dễ dàng thay đổi thông qua thuộc tính chat-title hoặc có thể thay đổi icon Dialogflow mặc định khi chat bot được tạo bằng icon khác thông qua thuộc tính chat-icon. Ngoài ra bạn cũng có thể thay đổi màu sắc khung chat, tin nhắn,… thông qua các biến CSS được định nghĩa sẵn, để xem thêm các tuỳ chọn thay đổi cho chat bot bạn có thể truy cập vào đường link này. Như vậy là chúng ta đã có một chat bot hoàn toàn miễn phí để tích hợp vào website của mình, tuy miễn phí nhưng lại cực kỳ lợi hại hơn nữa việc cấu hình để tạo ra một chat bot phù hợp theo nhu cầu của mình và cũng không quá phức tạp phải không nào (^_^) Nếu như bạn chỉ muốn có một chat bot để tư vấn chăm sóc khách hàng thôi thì đến đây là đủ, còn nếu như bạn có khả năng lập trình và muốn nâng cấp chat bot của mình để nó có thể thay bạn chốt đơn hàng như hình bên dưới thì bạn có thể tiếp tục xem phần tiếp theo của series này để tìm hiểu cách lập trình thu thập thông tin của người dùng (như tên, số điện thoại, địa chỉ) để tiến hành lên đơn hàng một cách tự động nhé!","link":"/AI/2020-04-26-build-chat-bot-with-dialogflow-part-5/"},{"title":"Tự tạo chatbot bán hàng với Dialogflow - Phần 6 (Tạo đơn hàng tự động)","text":"Ở trong các phần trước tôi đã hướng dẫn các bạn tạo ra một chat bot tư vấn về sữa bột cho trẻ em, câu chuyện mới chỉ dừng lại ở việc tư vấn về giá cả hoặc địa chỉ bán sữa cho người dùng, trong phần này chúng ta sẽ tiếp tục nghiên cứu cách thu thập thông tin người dùng và chốt đơn hàng. Để chat bot có thể nhận biết được khi nào người dùng cần mua sản phẩm thì trước tiên ta cần định nghĩa ra một Entity mới và đặt tên là eMuaHang. eMuaHang mua : mua, cần mua, muốn mua bán : bán, bán cho tôi, bán tôi đặt hàng : đặt hàng, đặt trước, đặt mua Tiếp theo ta cần tạo ra một Intent và dạy cho chat bot học những câu nói người dùng thường sử dụng để đặt mua hàng, đặt tên cho Intent này là iMuaHang. Training phrases cho tôi đặt hàng 1 hộp bán cho tôi 1 hộp tôi muốn mua 1 hộp Responses Đơn hàng của bạn đã được ghi nhận. Xin cảm ơn! Tại mục Action and parameters hiện tại có 1 parameter emuahang đã được tạo sẵn tự động dựa trên Entity eMuaHang, để có thể thu thập được thông tin khách hàng ta cần định nghĩa thêm các parameters khác để hứng các thông tin mà người dùng nhập vào như: tên, số điện thoại, địa chỉ,… Tạo parameter tên name: entity ta chọn sys.any, sau đó chọn vào ô required (để yêu cầu người dùng nhập vào tên của họ khi Intent này được kích hoạt) và click vào Define promp … trong cửa sổ hiện ra ta nhập vào các câu hỏi để yêu cầu người dùng nhập họ tên vào như: “Tên bạn là gì?” Tiếp tục tạo parameter tên address: entity vẫn chọn sys.any, chọn required và nhập yêu cầu người dùng cung cấp địa chỉ Cuối cùng tạo parameter tên phone: entity ta chọn sys.phone-number, chọn required và nhập yêu cầu người dùng cung cấp số điện thoạiLưu ý: các entity bắt đầu bằng “sys.” là những entity được định nghĩa sẵn bởi Dialogflow và nó có kiểm tra những gì người dùng nhập vào có đúng theo kiểu dữ liệu đã được định nghĩa không. Đó là lý do vì sau tôi chỉ chọn đúng kiểu sys.phone-number cho prameter phone vì chúng ta cần người dùng nhập đúng định dạng số điện thoại, còn đối với tên và địa chỉ thì Dialogflow vẫn có cung cấp entity tương ứng nhưng cách kiểm tra dữ liệu của Dialogflow không phù hợp với họ tên và địa chỉ tiếng Việt của mình nên tôi đã chọn kiểu any (cho phép người dùng nhập bất kỳ thông tin gì vô). Cuối cùng trong phần cấu hình Intent này ta kéo xuống mục Fulfillment ở cuối trang và mở tuỳ chọn Enable webhook call for this intent sau đó nhấn Save Intent này lại. Tuỳ chọn này cho phép Dialogflow gửi một request có chứa các thông tin của người dùng nhập vào tới web server của chúng ta, việc còn lại là chỉ cần lấy thông tin đó để tạo đơn hàng trên website của mình thôi. Các bạn cần tạo ra một đường dẫn đến webserver của bạn để hứng dữ liệu gửi về từ Dialogflow khi người dùng kích hoạt iMuaHang. Webserver bạn có thể sử dụng bất kỳ ngôn ngữ nào, ở đây tôi demo trên PHP và tôi tạo ra một file trigger.php trên webser của tôi với nội dung như sau: 1234&lt;?php$data = json_decode(file_get_contents('php://input'), true);print_r($data); Bây giờ bạn cần di chuyển sang mục Fulfillment trong menu bên phải và enable mục Webhook lên, tại ô URL các bạn điền đường dẫn đến file trigger.php trên webserver của bạn và nhấn Save lại. Hình bên dưới chính là nội dung mà ta nhận được từ Dialogflow khi người dùng kích hoạt Intent mua hàng.","link":"/AI/2020-04-27-build-chat-bot-with-dialogflow-part-6/"},{"title":"Tự tạo chatbot bán hàng với Dialogflow - Phần 2 (Khái niệm về Intents)","text":"Intent là đại diện cho một ánh xạ giữa những truy vấn mà người dùng đưa vào và hành động sẽ được thực hiện tương ứng từ hệ thống. Nói nôm na Intent là đại diện cho một mục đích, một ý định hay một yêu cầu cụ thể nào đó của người dùng. Trong phần 1 ta có ví dụ về chat bot tư vấn mua sữa, thì Intent ở đây là để thể hiện cho mục đích cần tìm mua sữa của các bà mẹ. Như vậy trong ví dụ này ta cần định nghĩa ra một Intent để tư vấn về sữa. Để tạo mới một Intent ta chọn vào mục Intents bên menu phải và nhấn vào CREATE INTENT, đặt tên cho Intent là iTuVan (bạn có thể đặt bất kỳ tên gì, ở đây tôi đặt theo định dạng có chữ i ở đầu để phân biệt đó là Intent và tên Intent viết theo kiểu lạc đà phía sau). Một intent về cơ bản sẽ bao gồm 4 thành phần chính sau: • Training phrases: là những câu thoại người dùng có thể nói, được lên sẵn để kích hoạt intent đó. Khi người dùng nói một câu truy vấn giống với một trong những câu thoại sẵn này thì Dialogflow sẽ kích hoạt Intent này. Tuy nhiên chúng ta không cần phải định nghĩa ra mọi câu thoại có thể xuất hiện bởi vì Dialogflow được xây dựng dựa trên máy học nên có khả năng tự mở rộng danh sách các câu thoại tương tự. Tại mục Training phrases\u001d trong Intent iTuVan ta có thể định nghĩa các training phrases mà người dùng hay nói như: cho hỏi về sữa bột cho trẻ mình cần tư vấn về sữa cho bé • Action: là những hành động ta định nghĩa ra cho mỗi Intent, khi Dialogflow tìm được intent phù hợp nó sẽ cung cấp hành động tương ứng tới hệ thống và ta có thể sử dụng hành động này để kích hoạt các tính năng của hệ thống. • Parameters: đây là một danh sách các tham số được dùng để trích xuất thông tin cần thiết từ lời yêu cầu của người dùng để xử lý ở fulfillment hoặc cũng có thể dùng để phản hồi về cho người dùng dưới dạng tham biến. Nó không giống như dữ liệu đầu vào của người dùng, các parameters là dữ liệu có cấu trúc mà có thể dễ dàng được sử dụng để biểu diễn các logic hoặc tạo ra các phản hồi. Thông thường trong các training phrases mà mình nhập vào sẽ có chứa các Entity trong đó và Dialogflow sẽ tự nhận diện và thêm xuống mục Action and parameters. Entity là gì tôi sẽ trình bày cụ thể ở những phần tiếp theo, ở phần này chúng ta chỉ cần tập trung vào câu nói yêu cầu của người dùng (Training phrases) và câu trả lời từ chat bot (Responses). • Responses: là những phản hồi được định nghĩa sẵn để trả lại cho người dùng, nó có thể là một câu trả lời cho một yêu cầu của người dùng hoặc có thể là lời yêu cầu người dùng cung cấp thêm thông tin hoặc một phản hồi kết thúc cuộc hội thoại. Cũng giống như Training pharases chúng ta cũng không cần phải định nghĩa đầy đủ các câu trả lời cho yêu cầu của người dùng, Dialogflow sử dụng máy học có khả năng tạo ra các câu trả lời phù hợp với từng ngữ cảnh khác nhau. Trong mục Responses ta có thể nhập vào các câu trả lời từ chat bot khi được người dùng hỏi tư vấn về sữa, nên sử dụng các câu trả lời mang tính gợi mở để dẫn dắt người dùng theo kịch bản mà ta đã xây dựng để có thể nhanh chóng chốt đơn đúng không ^^VD: bạn cần mua loại nào: Frisolac Gold, Nan Nestle, Physiolac, Morinaga, Meiji Như vậy trong phần này chúng ta đã cùng nhau tìm hiểu được các khái niệm cơ bản về Intent, nhưng nếu chỉ dừng lại ở mức người dùng hỏi cái gì chat bot trả lời lại đúng cái đó thôi thì không có gì hấp dẫn cả. Trong ví dụ ở phần 1 ta còn thấy được một khả năng đặc biệt ở Dialogflow nữa là có thể tạo ra chat bot có trí nhớ ngắn hạn, nghĩa là nó có thể ghi nhớ được câu trả lời trước đó của người dùng để sử dụng vào các ngữ cảnh sau. Cụ thể khi chat bot hỏi lại người dùng cần tìm sữa của hãng nào, người dùng trả lời “frisolac”, chat bot hỏi tiếp là muốn tìm chỗ mua hay muốn biết giá, người dùng trả lời “mình muốn biết giá hiện tại bao nhiêu” và chat bot trả lời lại chính xác giá của sữa frisolac mặc dù trong câu trả lời của người dùng trước đó không hề nhắc đến “frisolac”. Ở phần tiếp theo chúng ta sẽ cùng tìm hiểu cách để giúp chat bot có được trí nhớ ngắn hạn này nhé!","link":"/AI/2020-04-22-build-chat-bot-with-dialogflow-part-2/"},{"title":"Tự tạo chatbot bán hàng với Dialogflow - Phần 4 (Khái niệm về Entities)","text":"Entity là một cơ chế của Dialogflow giúp xác định và trích xuất các dữ liệu cần thiết từ yêu cầu của người dùng. Trong khi Intent giúp Agent có thể hiểu mục đích, ý định của người dùng thì Entity có thể giúp Agent trích xuất ra những thông tin chi tiết và cụ thể nhất của câu truy vấn. Ví dụ: trong câu nói “có bán sữa bột cho trẻ em không” của người dùng thì “có bán sữa” có thể xem là một Entity về tư vấn và nó sẽ kích hoạt Intent iTuVan. Một Entities bao gồm: Loại Entity: định nghĩa ra loại thông tin mà ta muốn trích xuất từ câu truy vấn của người dùng. Phần tử Entity: mỗi loại Entity sẽ có nhiều phần tử, mỗi phần tử cung cấp một tập các từ hoặc cụm từ được coi là tương đương Các từ đồng nghĩa và giá trị tham chiếu với Entity: một vài phần tử Entity có nhiều từ hoặc cụm từ mà có nghĩa tương đương nhau, với những Entity này ta cần cung cấp một giá trị tham chiếu và một hoặc nhiều từ, cụm từ đồng nghĩa. Ở phần trước chúng ta đã tạo ra các Intent để tư vấn về sản phẩm sữa bột Frisolac. Tiếp theo chúng ta cần tạo ra các Entities tương ứng tại mục Entities ở menu bên phải click vào nút CREATE ENTITY và đặt tên cho Entity đầu tiên là eTuVan (tôi đặt theo định dạng chữ ‘e’ đầu tiên để chỉ đó là một Entity và ‘TuVan’ là tên Entity). Loại Entity ta để chọn mặc định là Define synonyms, sau đó chọn Add a row sẽ xuất hiện 2 ô để nhập vào một giá trị Entity và các từ đồng nghĩa với Entity đó. eTuVanreference value: tư vấnsynonyms: tư vấn, muốn hỏi, cần hỏi, cần biết, muốn biết, hỏi, cho hỏi Như vậy khi người dùng nhập vào một câu có chứa các từ đồng nghĩa này thì Intent iTuVan sẽ được kích hoạt, tuy nhiên nếu người dùng không nhập vào 1 trong các từ đồng nghĩa mà ta đã nhập ở trên thì sao??? Câu trả lời là chat bot vẫn có thể nhận diện được nếu trong câu nói của người dùng có xuất hiện các từ tương tự với Entity mà ta đã định nghĩa đó là do Dialogflow xử dụng trí tuệ nhân tạo để học các từ đồng nghĩa mà ta nhập vào từ đó có thể suy luận ra các từ đồng nghĩa khác và kích hoạt Intent tương ứng. Cụ thể trong ví dụ của chúng ta thì câu nói của người dùng không chứa các từ đồng nghĩa trong eTuVan mà ta đã định nghĩa như có cụm từ “có bán sữa” là một cách nói khác với mục đích cuối cùng là muốn hỏi có bán sữa không, khi đó chat bot nhận diện được eTuVan và đã kích hoạt iTuVan thành công. Quay lại một xíu ở phần trước khi ta định nghĩa ra các Training phrases trong Intent iTuVan tôi cố tình nhập vào các câu có chứa các từ đồng nghĩa trong Entity eTuVan, ví dụ trong câu “cho hỏi về sữa bột cho trẻ” có chứa Entity eTuVan là từ “cho hỏi” khi đó chúng ta thấy từ này lập tức được Dialogflow highlight lên và eTuVan được tự động thêm vào mục Action and parameters. Như vậy mỗi khi câu nói của người dùng được Dialogflow xác định có chứa Entity eTuVan thì lập tức nó sẽ kích hoạt Intent iTuVan tương ứng. Chúng ta tiếp tục định nghĩa các Entities khác để xử lý các Intent về sản phẩm, giá bán và địa chỉ. eSanPhamreference value: Physiolacsynonyms: Physiolac, sữa physiolac, sữa pháp, sữa bột physiolac eGiareference value: giásynonyms: giá, giá bán, bao nhiêu tiền, giá bao nhiêu, giá hiện tại, bán bao nhiêu eDiaChireference value: mua ở đâusynonyms: mua ở đâu, mua, mua chỗ nào, chỗ mua reference value: bán ở đâusynonyms: bán ở đâu, bán, bán chỗ nào, chỗ bán, nời nào bán Ta có thể định nghĩa nhiều phần tử Entity khác nhau trong một Entity như ở Entity eDiaChi tôi định nghĩa 2 phần tử Entity là mua ở đâu và bán ở đâu. Như vậy khi người dùng có nhu cầu hỏi về chỗ mua hoặc chỗ bán thì đều sẽ được Dialogflow nhận diện đó là Entity eTuVan. Ở phần cuối của series hướng dẫn tạo chat bot bằng Dialogflow này tôi sẽ hướng dẫn các bạn cách tích hợp chat bot mà mình đã tạo trên Dialogflow vào website của mình.","link":"/AI/2020-04-25-build-chat-bot-with-dialogflow-part-4/"},{"title":"Concurrency và parallelism trong lập trình đa luồng","text":"Trong một bài phát biểu của Rob Pike ông đã từng nói “Concurrency Is Not Parallelism” đây là hai khái niệm mà chúng ta thường hay gặp trong khi lập trình đa luồng và chắc chắn là nhiều bạn vẫn còn nhầm lẫn về hai khái niệm này. Vậy thì chúng ta hãy cùng nhau tìm hiểu rõ hơn thông qua bài viết này nhé! Để dễ hình dung chúng ta hãy thử tưởng tượng một chương trình máy tính cũng giống như một dự án trong công ty. Một thành viên trong nhóm thực hiện dự án tương đương với một nhân CPU. Và mỗi công việc cần phải làm trong dự án là một request đến chương trình máy tính. Giả sử để hoàn thành dự án thì cần phải thực hiện 3 công việc, ta tạm thời gọi 3 công việc đó là 3 task A, B, C tương ứng mà một chương trình máy tính cần hoàn thành. Xử lý tuần tự (Sequential)Để hoàn thành dự án một nhân viên A sẽ phải thực hiện lần lượt các task như sau: Đầu tiên là thực hiện task A Xong task A thì sẽ thực hiện task B Xong task B thì sẽ thực hiện task C Tương tự như vậy để hoàn thành một tác vụ thì chương trình máy tính cũng sẽ phải thực hiện tuần tự task A, rồi đến B, rồi mới đến C. Do trước đây máy tính chỉ có 1 nhân CPU nên cách hoạt động cũng dựa trên mô hình lập trình tuần tự. Xử lý song song (Parallelism)Ngay nay thì công nghệ phát triển vì vậy mà máy tính cũng có nhiều nhân CPU hơn. Cũng giống như trong dự án sẽ có nhiều thành viên hơn, mỗi người sẽ đảm nhận một công việc riêng và sẽ làm việc cùng lúc với nhau. Nhân viên A thực hiện task A Nhân viên B thực hiện task B Nhân viên C thực hiện task C Tương tự như một chương trình máy tính sử dụng nhiều nhân CPU để thực hiện một tác vụ, mỗi nhân sẽ xử lý một task riêng biệt và tác vụ chỉ hoàn thành khi tất cả các task được xử lý xong, giống như dự án chỉ hoàn thành khi cả 3 nhân viên thực hiện xong hết công việc của mình. Xử lý đồng thời (Concurrency)Gần giống như việc xử lý song song tuy nhiên thay vì mỗi nhân viên phải thực hiện hết 1 công việc thì ý tưởng xử lý đồng thời sẽ là chia nhỏ công việc đó (task) thành các công việc nhỏ hơn (gọi là subtask). Khi đó mỗi nhân viên sẽ thực hiện một subtask bất kỳ không cần biết nó thuộc task nào chỉ cần đảm bảo 2 nhân viên không thực hiện cùng một subtask, khi hoàn tất một subtask này sẽ chuyển sang làm subtask khác. Như vậy sẽ có thể tận dụng được tối đa nguồn lực sẵn có, tận dụng được các khoảng thời gian chết của mỗi thành viên để thực hiện các subtask khác. Tổng kếtNhư vậy qua bài viết này chúng ta có thể thấy rõ đồng thời không phải là song song như nhận định của Rob Pike. Tuỳ vào từng trường hợp và bài toán cụ thể mà chúng ta sẽ quyết định lựa chọn phương pháp nào cho phù hợp. Ví dụ như đối với trường hợp máy tính chỉ có 1 nhân thì không thể chạy theo cơ chế Parallelism được. Trong trình duyệt Cốc Cốc ta thấy khi download file thì sẽ được chia nhỏ thành nhiều phần tải xuống song song để tăng tốc độ download, đây là một ví dụ về xử lý song song. Hay ứng dụng trình duyệt web là một ví dụ cho việc sử dụng cơ chế Concurrency, bởi vì ta thấy trên trình duyệt ta có thể vừa nghe nhạc, đọc báo, download file,…Hy vọng sau khi đọc xong bài viết này sẽ giúp các bạn phần nào hiểu rõ hơn và có thể phân biệt được 2 khái niệm này trong lập trình đa luồng ^^","link":"/system/2020-08-12-concurrency-and-parallelism-in-multithreading-programing/"},{"title":"Dependency injection trong React với JSX và context","text":"Dependency injection là một dạng design pattern phổ biến được áp dụng vào để cố gắng đạt được sự không phụ thuộc giữa các object với nhau làm cho code clean hơn, dễ đọc và dễ test. Nó cũng được tích hợp sẵn trong nhiều framework lập trình như Angular, Symfony, Spring,… Các dạng dependency injection Constructor injection: là dạng được sử dụng phổ biến nhất, bằng cách truyền các dependency vào 1 class thông qua constructor của class đó. Setter injection: đối với dạng này thì các dependency sẽ được truyền vào 1 class thông qua các hàm Setter của class đó. Interface injection: để thực hiện ta cần phải tạo ra 1 interface chứa 1 hàm Inject và class cần injection sẽ implement interface này. Container sẽ truyền dependency vào 1 class bằng cách gọi hàm Inject của interface đó. Dependency injection trong React JSThẳng thắng mà nói thì trong React không có dependency injection container như trong Angular hay một số famework có tích hợp sẵn design pattern này. Tuy nhiên khi sử dụng React chúng ta hoàn toàn có thể thực thi các dependency injection một cách dễ dàng thông qua JSX và context có sẵn trong React mà không cần đến dependency injection container. JSX trong React cho phép chúng ta di chuyển, thay thế linh động các dependency cũng như cấu hình chúng thông qua việc chia tách các components và truyền vào nhau thông qua props. Ngoài ra để thuận tiện hơn trong việc truyền qua nhiều lớp components nested hay nói cách khác để tránh wrapper hell thì React cung cấp thêm cho chúng ta một công cụ nữa đó là context. Dưới đây là một ví dụ về việc sử dụng context để tạo ra một service component xác thực người dùng: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import { createContext, useContext, useState, useEffect } from \"react\";interface Auth { isAuthenticated: boolean; setToken: (token: string) =&gt; void; clearToken: () =&gt; void;}const AuthContext = createContext({} as Auth);export const AuthProvider = ({ children }) =&gt; { const [logined, setLogined] = useState(true); useEffect(() =&gt; { const token = localStorage.getItem(\"token\"); if (!token) { setLogined(false); } else { redirectAfterLogin(); } }, []); const setToken = async (token: string) =&gt; { await localStorage.setItem(\"token\", token); setLogined(true); redirectAfterLogin(); }; const clearToken = async () =&gt; { await localStorage.removeItem(\"token\"); setLogined(false); redirectAfterLogout(); }; const redirectAfterLogin = () =&gt; { window.location.href = \"/home\"; }; const redirectAfterLogout = () =&gt; { window.location.href = \"/login\"; }; return ( &lt;AuthContext.Provider value={{ setToken, clearToken, isAuthenticated: logined }} &gt; {children} &lt;/AuthContext.Provider&gt; );} Trong đoạn code trên mình có sử dụng một tính năng mới được React thêm vào từ phiên bản React 16.8 đó là React Hook. Vì vậy ở ví dụ trên chúng ta có thể định nghĩa ra các hook để tiện sử dụng ở các component khác hơn: 1234export const useAuth = () =&gt; { const authContext: Auth = useContext(AuthContext); return authContext;}; Chúng ta có thể wrap application lại bằng AuthProvider và handle các components dựa trên trạng thái đăng nhập của user như hàm bên dưới. 123456789101112131415161718export function ProtectRoute(Component) { return () =&gt; { const { isAuthenticated } = useAuth(); const pathName = window.location.pathname; useEffect(() =&gt; { if (!isAuthenticated) { window.location.href = \"/login\"; } else if ( isAuthenticated &amp;&amp; (pathName === \"/\" || pathName === \"/login\") ) { window.location.href = \"/home\"; } }, [isAuthenticated]); return &lt;Component /&gt;; };}","link":"/React-JS/2020-09-16-dependency-injection-in-react-with-jsx-and-context/"},{"title":"How to handle expired token in javascript?","text":"We often have to work with so many different APIs in a project so what if we are currently calling all three APIs at once and the token expires?Then all three API requests will call for a token refresh, but only one API will call the token refresh successfully and the other two APIs will fail because the token refresh mechanism will cancel the expiring token as soon as it is refreshed. SOLVE–request 1–&gt; (token expired detection)–request 2–&gt; (later requests must wait for the token to return)–request 3–&gt; (no matter how many requests you have to wait) The following code simulates the programming process when token expires 123456789101112131415161718192021222324252627282930313233343536373839404142const isTokenExpired = truelet token = 'Current token'const refreshToken = (api_request_token) =&gt; { console.log('Api request new token:', api_request_token) return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { console.log('\\n') resolve('This is new token') }, 2000) })}let refreshTokenRequest = nullconst requestApi = async (url) =&gt; { if (isTokenExpired) { console.log('Request api with token expired:', url, token) refreshTokenRequest = refreshTokenRequest ? refreshTokenRequest : refreshToken(url) const newToken = await refreshTokenRequest refreshTokenRequest = null token = newToken } console.log('Request api:', url, token)}(main = () =&gt; { requestApi('/me') requestApi('/products') requestApi('/posts')})()// Result// Request api with token expired: /me Current token// Api request new token: /me// Request api with token expired: /products Current token// Request api with token expired: /posts Current token// Request api: /me This is new token// Request api: /products This is new token// Request api: /posts This is new token","link":"/Javascript/2020-07-04-how-to-handle-expired-token-in-javascript/"},{"title":"Responsive table with pure CSS","text":"The idea here is to turn each &lt;td&gt; in &lt;t&gt; of &lt;tbody&gt; into one line so each &lt;tr&gt; will be a block. The css below will help you do that. make like a row12345678td { border: none; border-bottom: 1px solid #eee; position: relative; padding-left: 50%; background-color: #F8D9D5; text-align: left; } Next we need to remove &lt;thead&gt; in mobile and convert it into a label in each &lt;td&gt; by using attr() method in css. convert header to label12345678td:before { content: attr(data-label); display: inline-block; line-height: 1.5; margin-left: -100%; width: 100%; white-space: nowrap;} This is a demo","link":"/CSS-Magic/2020-04-05-responsive-table-with-pure-css/"},{"title":"Tự tạo một react component và publish lên NPM","text":"Chắc hẳn tất cả mọi người khi làm việc với React JS đều phải biết tới NPM, đây thật sự là một công cụ tuyệt vời để quản lý các thư viện mã nguồn mở trong thế giới Javascript nói chung và React JS nói riêng. Vậy làm thế nào để publish một component của riêng mình lên NPM? Việc chia tách một ứng dụng lớn thành những component nhỏ hơn sẽ giúp chúng ta quản lý code được tốt hơn, cũng như có thể tái sử dụng lại được nhiều lần. Đặc biệt là trong React JS thì việc này lại càng thật sự cần thiết, cách thông thường chúng ta hay làm là sẽ copy code của các component hay sử dụng đi sử dụng lại vào cất ở đâu đó và khi cần thì copy ra xài. Thay vì phải thực hiện thủ công như vậy thì chúng ta có 1 cách khác hay hơn là đóng gói component đó lại và publish nó lên NPM để khi cần chỉ cần 1 lệnh install là xong! Chúng ta có thể publish lên NPM ở chế độ private để chỉ có mình sử dụng thôi hoặc chế độ public để chia sẻ cho cộng đồng cùng sử dụng. Sau khi tìm hiểu qua một số hướng dẫn trên internet thì tôi thấy có một thư viện hỗ trợ thực hiện việc này khá tốt và cũng dễ sử dụng. Thư viện đó tên là create-react-library, nó là một CLI nhỏ gọn giúp chúng ta dễ dàng tạo ra một React component có thể tái sử dụng thông qua NPM. Cách sử dụngĐể publish một package mới lên NPM trước tiên chúng ta cần truy cập vào đường dẫn https://www.npmjs.com/ và search thử tên package mà chúng ta định publish có trùng với ai khác chưa, nếu có thì hãy chọn 1 tên khác. Tiếp theo ta mở terminal lên và sử dụng lệnh sau để khởi tạo một React component 1npx create-react-library &lt;your-package-name&gt; Ví dụ trong bài hướng dẫn này tôi sẽ tạo một Flashcard component, vì vậy tôi sẽ khởi tạo như sau: 1npx create-react-library react-flashcard Chúng ta tiến hành nhập vào các thông tin cần thiết để khởi tạo package để publish lên NPM. Sau khi nhập đầy đủ các thông tin theo yêu cầu thì một thư mục react-flashcard được sinh ra tự động từ create-react-library, đây chính là cấu trúc thư mục được tạo sẵn để chúng ta viết React component và đóng gói theo đúng chuẩn của NPM. Tiếp theo chúng ta mở 2 cửa sổ terminal lên, một bên sẽ để chạy lệnh sau để theo dõi sự thay đổi code trong thư mục src và rebuild lại mỗi khi chúng ta lập trình cho React component này. 1cd react-flashcard &amp;&amp; npm start Và cửa sổ còn lại sẽ chạy một ứng dụng React với component mà chúng ta đang viết được nhúng sẵn vào trong đó. 12cd react-flashcardcd example &amp;&amp; npm start Đây là code mẫu cho package react-flashcard của tôi: https://github.com/ozuit/react-flashcard Publish lên NPMSau khi đã hoàn tất component React của mình rồi thì chúng ta cần login vào npm từ terminal của mình để có thể publish lên cloud bằng cách chạy câu lệnh sau: 1npm adduser Login vào bằng tài khoản NPM của mình (click vào đây để đăng ký nếu chưa có tài khoản). Sau khi login thành công thì chỉ cần chạy tiếp lệnh bên dứoi để publish package của mình lên NPM ở chế độ private 1npm publish hoặc chạy lệnh sau để publish lên NPM ở chế độ public 1npm publish --access=public Đây là package của tôi sau khi được publish lên NPM: https://www.npmjs.com/package/react-flashcard Deploy demoMột điểm thú vị nữa ở thư viện create-react-library là nó cho phép chúng ta có thể deploy nhanh một demo cho React component mà chúng ta vừa tạo lên Github page thông qua câu lệnh bên dưới: 1npm run deploy Đây là demo Flashcard component của tôi: https://ozuit.github.io/react-flashcard/","link":"/React-JS/2020-12-24-how-to-publish-a-react-component-to-npm/"},{"title":"React Native With Socket.io Client","text":"Install socket.io-client libraryCopy and run following command at project’s root folder. 1npm i socket.io-client --save How to useImport new library have installed to projectYou need to import the correct path as below for this library to work. 1import io from 'socket.io-client/dist/socket.io'; Connect to socket server and listen eventYou can make an connect to socket server in constructor function. 1234567constructor(props) { super(props); this.socket = io('http://yoursocketserver', {jsonp: false}); this.socket.on('event', function (data) { // writing your code to handle data here });} Function this.socket.on() to listen an event from socket server Send an event and data to socket serverTo call an event to socket server you can using emit function. 1this.socket.emit('event', data);","link":"/React-Native/2020-04-02-react-native-with-socket-io-client/"},{"title":"React Hook với Redux Toolkit - sự kết hợp hoàn hảo","text":"Nếu bạn nào đã từng sử dụng qua React chắc hẳn sẽ gặp phải những rắc rối với việc quản lý các global state, một trong những giải pháp mà đa số mọi người hay dùng đó là sử dụng Redux và bạn phải wrap mọi React component bằng higher-order connect() component, việc setup một React project với Redux trước đây khá là phức tạp. Nhưng từ bản React 16.8 thì hooks đã được cập nhật thêm vào và sau đó thì team Redux cũng đã cập nhật thêm vào thư viện React Redux của mình các hook mới và có thể thay thế cho việc dụng connect() như trước đây. Functional vs Class-ComponentChúng ta đều đã biết để định nghĩa một component trong React thì cách đơn giản nhất là sử dụng một Javascript function, function này đơn giản chỉ là nhận vào props và trả về một React element: 123function Welcome(props) { return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;;} Tuy nhiên bạn cũng có thể sử dụng cú pháp trong ES6 để tạo ra một component giống vậy 12345class Welcome extends React.Component { render() { return &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;; }} Cả 2 cách trên đều cho chúng ta cùng một kết quả như nhau, nhưng ở đây có vài điểm khác biệt là trong class component thì bạn có thể tạo ra các state và handle việc render lại view thông qua hàm setState và sử dụng các hàm trong lifecycle được thừa kế từ React component, còn functional component thì không thể hay nói cách khác nó là stateless. Sự ra đời của React hookBởi vì functional component thì dễ dàng hơn cho việc đọc code cũng như viết test bởi vì nó không có các thành phần state hoặc lifecycle như trong class component, bạn có thể dễ dàng tách rời view với các xử lý logic. Nhưng thứ tuyệt vời hơn mà mọi developer đều mong muốn đó là bạn sẽ được code ít hơn 😎 và thứ mà người dùng mong muốn là performance của ứng dụng sẽ được tăng lên đáng kể. Một ví dụ dễ thấy trong trường hợp này là việc Facebook rebuild lại app Messenger của mình trên nền tảng IOS, họ đã giảm từ 1,7 triệu dòng code xuống còn 360.000 dòng và giờ đây ứng dụng của họ nhẹ hơn 1/4 và phản hồi nhanh hơn gấp đôi so với trước đây. Tuy nhiên functional component trong React lại không hỗ trợ state và thiếu đi các phương thức trong lifecycle, đó chính là lý do cho sự ra đời của React hook một trong những bổ sung quan trọng trong bản React 16.8 đó là sự góp mặt của hook-state và hook-effect. Để sử dụng hook-state ta gọi hàm useState() trong React với tham số truyền vào là giá trị khởi tạo ban đầu của state và hàm này sẽ trả về một cặp giá trị bao gồm giá trị state hiện tại và một hàm để cập nhật state mới. Hook này thay thế cho hàm setState() được sử dụng trong class component. 1const [time, setTime] = useState(new Date()) Để sử dụng hook-effect ta gọi hàm useEffect() trong React với tham số truyền vào là một function (thay thế cho componentDidMount) và có thể trả về một function (thay thế cho componentWillUnMount). Hook này được dùng để thay thế cho các phương thức trong lifecyle được sử dụng trong class component, nó được gọi mỗi khi Dom được cập nhật. 12345678910const changeTime = () =&gt; { setTime(new Date())}useEffect(() =&gt; { const tick = setInterval(() =&gt; { changeTime() }, 1000) return () =&gt; clearInterval(tick)}) Sự kết hợp React với Redux Toolkit thông qua react-reduxNhư mình đã đề cập ở trên thì sau khi React hook ra đời team Redux họ cũng đã update thêm vào thư viện react-redux của mình hai hook quan trọng là useSelector() và useDispatch() thay thế cho hàm connect() trước đây để lấy các state từ store ra và dispatch actions để cập nhật lại store. Vậy thì còn Redux Toolkit là cái gì nữa, trước đây khi chưa có nó thì để quản lý được state trong Redux chúng ta cần tạo ra một reducer với giá trị state khởi tạo và các hàm để cập nhật lại state, tiếp tục tạo ra các actions tương ứng với các hàm thay đổi state, việc này khá là mất thời gian và hơn nữa mỗi lần muốn cập nhật state chúng ta phải clone ra một state mới chứ không thể mutate state trực tiếp được. Vì vậy mà team Redux họ đã tạo ra Redux Toolkit, mục đích chính là để đơn giản hoá việc cấu hình Redux store, loại bỏ bớt các boilerplate code và bổ sung thêm vào các package hữu ích cho developer như redux-thunk, Redux Devtool. Cung cấp các api createReducer() và createAction giúp việc tạo ra các reducers và actions dễ dàng hơn với khả năng mutate state trực tiếp thông qua thư viện immer được tích hợp sẵn. Bạn có thể tìm hiểu thêm nhiều tính năng mới hữu ích về Redux Toolkit ở đây [link]. Một trong những api mà mình thích nhất khi sử dụng Redux Toolkit đó là createSlice(), nó nhận vào một list các hàm cập nhật state dưới dạng object, một slice name và một giá trị khởi tạo cho state. Chúng ta sẽ nhận lại được đồng thời reducer và các actions tương ứng, rất gọn gàng và dễ đọc. 123456789101112131415161718const counterSlice = createSlice({ name: 'counter', // tên của slice initialState: { value: 0 }, // gía trị khở tạo của state reducers: { increment(state, action) { state.value += 1 // mutate state trực tiếp }, decrement(state, action) { state.value -= 1 } }})const { increment, decrement } = counterSlice.actions // actions được export raconst store = configureStore({ reducer: counterSlice.reducer // reducer được export ra}) Tóm lại mình thấy rằng React hook ra đời là một điều cần thiết và điều đó cũng không có nghĩa là class component sẽ bị khai tử, chính Facebook họ cũng thừa nhận rằng họ không hề có ý định làm điều đó mà React hook ra đời với khả năng tương thích ngược, có nghĩa là bạn vẫn có thể sử dụng class component cho dự án của mình nếu như trước giờ bạn đang làm việc với nó. Nhưng nếu bạn đang chuẩn bị build một ứng dụng khác bằng React thì hãy cân nhắc cho việc sử dụng functional component với React hook dựa trên những ưu điểm vượt trội của nó và có thể sử dụng kết hợp với slice của Redux Toolkit thì còn tuyệt vời hơn nữa hoặc với project đang thực hiện bạn cũng có thể chuyển dần qua sử dụng functional với các hook cho các component mới, bạn hoàn toàn có thể sử dụng cả 2 cách mà không gặp bất kỳ trở ngại nào về cả.","link":"/React-JS/2020-09-10-the-perfect-combination-of-react-hook-and-redux-tool-kit/"},{"title":"Using arrow function in React JS - Callback","text":"When you need to perform setState in a callback function, for example call api and update the data as below 12345678910axios.get('http://yourdomain/api/get-data') .then(function (response) { // handle success this.setState({ data: response.data }) }) .catch(function (error) { // handle error }) Using the usual callback function like this you will get an error that this.setState is not a functionTo fix this you usually create a variable outside the callback function to store this pointer as below 1234567891011const that = thisaxios.get('http://yourdomain/api/get-data') .then(function (response) { // handle success that.setState({ data: response.data }) }) .catch(function (error) { // handle error }) However, you can also handle this problem by using the arrow function 12345678910axios.get('http://yourdomain/api/get-data') .then((response) =&gt; { // handle success this.setState({ data: response.data }) }) .catch((error) =&gt; { // handle error })","link":"/React-JS/2020-04-03-using-arrow-function-in-react-js-callback/"},{"title":"Using arrow function in React JS - Bind","text":"When programming applications with React Js to handle events you need to use the bind method. There are many different ways you can do that, such as placing it in a constructor 1234constructor(props) { super(props); this.handleClick = this.handleClick.bind(this);} Or you can also call it in the render function but this way will likely degrade your application performance, but in most cases it is negligible. 1234567render() { return ( &lt;button onClick={this.handleClick.bind(this)}&gt; Click me &lt;/button&gt; );} However there is another way to make your code more concise and readable by using the arrow function 1234567891011handleClick = () =&gt; { // handling event here}render() { return ( &lt;button onClick={this.handleClick}&gt; Click me &lt;/button&gt; );} P/S: This method also helps to optimize the performance of your application similar to the use of bind in constructor.","link":"/React-JS/2020-04-03-using-arrow-function-in-react-js-bind/"},{"title":"Sử dụng gRPC-Web để gọi API từ grpc server trong ứng dụng React JS","text":"Bài viết này sẽ trả lời cho các câu hỏi gRPC-Web là gì? Tại sao cần sử dụng nó? Và cách sử dụng gRPC-Web trong một ứng dụng React JS như thế nào thông qua một demo nho nhỏ. Ok, bắt đầu thôi nào! Why?Từ khi bắt đầu lập trình ứng dụng web / mobile mình đã biết đến những ưu điểm tuyệt vời của REST so với SOAP trong việc giao tiếp với backend thông qua APIs, vì thế mà mình chỉ sử dụng mỗi REST cho đến khi được công ty yêu cầu tìm hiểu về RPC - một kiến trúc API khác được thiết kế tập trung vào action thay vì resource như REST. Nếu bạn cũng ở trong hoàn cảnh giống tôi chắc hẳn bạn cũng sẽ tự đặt ra cho mình câu hỏi “tại sao lại phải chuyển qua sử dụng RPC thay vì REST ?” Để trả lời được cho câu hỏi này thì bạn cần phải tìm hiểu thêm về anh Protobuf này, bởi vì gRPC sử dụng nó và có nhiều lý do để chọn Protobuf hơn là JSON truyền thống nhưng mà lý do mà mình ấn tượng nhất là tốc độ của nó thật sự rất nhanh (một phần là vì dung lượng gói tin của nó nhỏ gọn và truyền tải theo binary nên cực kỳ tối ưu cho máy tính), nếu muốn xem Protobuf đánh bại JSON như thế nào thì bạn có thể xem thêm ở đây [link]. What?Quay trở lại câu hỏi đề bài nào! Thế thì còn gRPC-Web là ông thần nào nữa? Ta đã biết gRPC là một RPC framework do Google phát triển và sử dụng Protobuf để tranfer data thay vì JSON/XML truyền thống nên tốc độ được gia tăng đáng kể, gRPC hỗ trợ rất nhiều ngôn ngữ lập trình để tích hợp trên mobile, backend service và cả trên trình duyệt. Và trong bài viết này mình muốn giới thiệu với các bạn về gRPC-Web, một thư viện Javascript hỗ trợ trình duyệt giao tiếp với gRPC service. How?Bởi vì gRPC-Web không hỗ trợ HTTP/2 vì vậy chúng ta cần một gateway proxy, thường chúng ta sẽ sử dụng Envoy để translate request từ HTTP/1 sang HTTP/2. Đồng thời Envoy cũng sẽ hỗ trợ cấu hình cho phép CORS request. Chúng ta có thể build một Envoy proxy dễ dàng với Docker thông qua file cấu hình envoy.yaml và chạy nó với câu lệnh sau: 12docker run -d -v \"$(pwd)\"/envoy.yaml:/etc/envoy/envoy.yaml:ro \\ -p 8080:8080 -p 9901:9901 envoyproxy/envoy:v1.15.0 Bây giờ để minh hoạ cho việc chạy gRPC-Web trên React JS mình sẽ tạo ra một gRPC service nhỏ bằng NodeJS sẽ nhận vào request là tên một người và response trả về sẽ là lời chào “Hello! + &lt;tên người đó&gt;”. Đầu tiên chúng ta cần định nghĩa ra file proto như bên dưới: 123456789101112131415syntax = \"proto3\";package helloworld;service Greeter { rpc SayHello (HelloRequest) returns (HelloReply);}message HelloRequest { string name = 1;}message HelloReply { string message = 1;} Để build một server gRPC với NodeJS chúng ta cần sử dụng proto-loader để load file proto của chúng ta lên và grpc-js để implement các service mà ta đã định nghĩa trong file proto. 123456789101112131415161718192021222324var PROTO_PATH = __dirname + \"/helloworld.proto\";var assert = require(\"assert\");var async = require(\"async\");var _ = require(\"lodash\");var grpc = require(\"@grpc/grpc-js\");var protoLoader = require(\"@grpc/proto-loader\");var packageDefinition = protoLoader.loadSync(PROTO_PATH, { keepCase: true, longs: String, enums: String, defaults: true, oneofs: true,});var protoDescriptor = grpc.loadPackageDefinition(packageDefinition);var helloworld = protoDescriptor.helloworld;/** * @param {!Object} call * @param {function():?} callback */function doSayHello(call, callback) { callback(null, { message: \"Hello! \" + call.request.name });} Tiếp theo để biên dịch file proto này thành code Javascript để trình duyệt có thể đọc được chúng ta cần sử dụng một compiler tên là protoc, các bạn có thể cài đặt theo hướng dẫn ở đây [link]. Sau khi cài đặt thành công thì chúng ta tiến hành biên dịch bằng cách chạy câu lệnh sau: 123protoc -I=. helloworld.proto \\ --js_out=import_style=commonjs:. \\ --grpc-web_out=import_style=commonjs,mode=grpcwebtext:. Cuối cùng việc còn lại là implement các file grpc được biên dịch ra từ tool protoc vào ứng dụng React JS 123456789101112131415161718192021import { GreeterClient } from '../rpc/helloworld_grpc_web_pb.js';import { HelloRequest, RepeatHelloRequest } from '../rpc/helloworld_pb.js';const URL = \"http://\" + window.location.hostname + \":8080\";const client = new GreeterClient(URL, null, null);const metadata = { 'custom-header-1': 'value1' };export default { sayHello: (name, callback) =&gt; { const request = new HelloRequest(); request.setName(name); client.sayHello(request, metadata, callback); }, sayRepeatHello: ({ name, count }) =&gt; { const streamRequest = new RepeatHelloRequest(); streamRequest.setName(name); streamRequest.setCount(count); return client.sayRepeatHello(streamRequest, metadata); },}; Như vậy là chúng ta đã cùng nhau tìm hiểu xong các vấn đề xoay quanh liên quan đến gRPC-Web và cách triển khai nó, tóm lại mình không khuyên các bạn từ bỏ REST để chuyển sang dùng gRPC hoàn toàn nếu như dự án trước giờ bạn đang làm vẫn đang hoạt động tốt với REST thì hết tiếp tục với nó, nếu như ứng dụng của bạn cần tối ưu hơn về tốc độ hoặc bạn đang bắt đầu một dự án mới thì hãy cân nhắc việc sử dụng gRPC, việc triển khai trên môi trường web application là hoàn toàn khả thi. Dưới đây là đường link repo github chứa full code demo nếu bạn cần tham khảo chi tiết.Link code demo: https://github.com/ozuit/react-grpc-web","link":"/React-JS/2020-09-08-using-grpc-web-to-call-api-from-grpc-server-in-react-application/"},{"title":"Step by step to deploy code to the server with CI/CD on Gitlab","text":"This post will show you how to set up a pipeline on Gitlab to deploy code to the server automatically whenever a merge request is made. I will try creating a pipeline deploy code to a sandbox environment to test before doing the code merge. Ok! let go… Step 1: Install GitLab RunnerFirst, you need to access your server via ssh and then we install Gitlab runner using binary file. Please select the version that suitable for your server’s operating system. In my case, I choose to install on Linux x86-64. 12345sudo curl -L --output /usr/local/bin/gitlab-runner https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-linux-amd64sudo chmod +x /usr/local/bin/gitlab-runnersudo useradd --comment 'GitLab Runner' --create-home gitlab-runner --shell /bin/bashsudo gitlab-runner install --user=gitlab-runner --working-directory=/home/gitlab-runnersudo gitlab-runner start Second, back to Gitlab and go to Settings &gt; CI/CD and expand the Runners section. Note the URL and token because you will need it to register the runner. 1sudo gitlab-runner register Step 2: Make .gitlab-ci.yml fileThis file will be used to describe for Gitlab how to pipeline flow running. Below is an basic example file I use to deploy the code to the sandbox every time a merge request is made. 1234567891011121314stages: - deploydeploy_sandbox: stage: deploy tags: - demo - sandbox script: - npm install - npm run build:sandbox - sudo cp -R dist/* /home/ozuit/mydomain.com only: - merge_requests You can find more examples in here: GitLab CI/CD Examples Step 3: Deploy with Gitlab pipeline Commit your file and push it to the Gitlab repo. Try to make a merge request and switch to CI/CD &gt; Pipelines to view processing.","link":"/DevOps/2020-10-23-setup-ci-cd-on-gitlab-to-deploy-code-to-the-server/"},{"title":"Submit multiple apps that the same UI to App Store","text":"In this post, I wanna share with you 3 ways to submit multiple apps that have the same UI to App Store. ContextYou have many apps for language learning such as English, German, Thai, and so on.Every app includes functions: listening, speaking, reading, and writing. They have the same UI and are just different content. ProblemYou submit all of the apps to App Store and are rejected as below Guideline 4.3 - Design This app duplicates the content and functionality of other apps submitted by you or another developer to the App Store, which is considered a form of spam. Apps that simply duplicate content or functionality create clutter, diminish the overall experience for the end user, and reduce the ability of developers to market their apps. The next submission of this app may require a longer review time, and this app will not be eligible for an expedited review until this issue is resolved. Next Steps Review the Design section of the App Store Review Guidelines. Ensure your app is compliant with all sections of the App Store Review Guidelines and the Terms &amp; Conditions of the Apple Developer Program. Once your app is fully compliant, resubmit your app for review. Submitting apps designed to mislead or harm customers or evade the review process may result in the termination of your Apple Developer Program account. Review the Terms &amp; Conditions of the Apple Developer Program to learn more about our policies regarding termination. Solution Create a new account for each app Set distribution of the apps to each other country Change UI to each other apps","link":"/Tuts/2022-07-22-submit-multiple-apps-that-the-same-UI-to-App-Store/"},{"title":"How to call child method from parent in react","text":"We usually pass the props to the child component from parent and pass notifications to parent by events. But sometimes we have some abnormal cases that we need to call the child method from the parent. In this, we could use Refs in React for solving. For React with Hooks (v16.8+) 1234567891011121314151617181920const ChildComponent = forwardRef((props, ref) =&gt; { useImperativeHandle(ref, () =&gt; ({ sayHello() { alert(\"Hello from Child\"); } })); return &lt;h1&gt;Child Component&lt;/h1&gt;;});const ParentComponent = () =&gt; { const childRef = useRef(); return ( &lt;div&gt; &lt;ChildComponent ref={childRef} /&gt; &lt;button onClick={() =&gt; childRef.current.sayHello()}&gt;Call child method&lt;/button&gt; &lt;/div&gt; );}; For using Class Component 12345678910111213141516171819202122232425class ChildComponent extends Component { sayHello() { alert('Hello from Child'); } render() { return &lt;h1&gt;Child Component&lt;/h1&gt;; }}class ParentComponent extends Component { constructor(props) { super(props); this.childRef = React.createRef(); } render() { return ( &lt;div&gt; &lt;ChildComponent ref={this.childRef} /&gt; &lt;button onClick={() =&gt; this.childRef.current.sayHello()}&gt;Click&lt;/button&gt; &lt;/div&gt; ); }}","link":"/Javascript/2022-01-05-how-to-call-child-method-from-parent-in-react/"}],"tags":[{"name":"React Native","slug":"React-Native","link":"/tags/React-Native/"},{"name":"Optimal","slug":"Optimal","link":"/tags/Optimal/"},{"name":"AI","slug":"AI","link":"/tags/AI/"},{"name":"Chatbot","slug":"Chatbot","link":"/tags/Chatbot/"},{"name":"Dialogflow","slug":"Dialogflow","link":"/tags/Dialogflow/"},{"name":"Speech to Text","slug":"Speech-to-Text","link":"/tags/Speech-to-Text/"},{"name":"Text to Speech","slug":"Text-to-Speech","link":"/tags/Text-to-Speech/"},{"name":"Tutorial","slug":"Tutorial","link":"/tags/Tutorial/"},{"name":"threads","slug":"threads","link":"/tags/threads/"},{"name":"React JS","slug":"React-JS","link":"/tags/React-JS/"},{"name":"React Hook","slug":"React-Hook","link":"/tags/React-Hook/"},{"name":"Context","slug":"Context","link":"/tags/Context/"},{"name":"Javascript","slug":"Javascript","link":"/tags/Javascript/"},{"name":"Responsive","slug":"Responsive","link":"/tags/Responsive/"},{"name":"npm","slug":"npm","link":"/tags/npm/"},{"name":"Socket.io","slug":"Socket-io","link":"/tags/Socket-io/"},{"name":"Redux Tool Kit","slug":"Redux-Tool-Kit","link":"/tags/Redux-Tool-Kit/"},{"name":"Hook","slug":"Hook","link":"/tags/Hook/"},{"name":"Arrow Function","slug":"Arrow-Function","link":"/tags/Arrow-Function/"},{"name":"Callback","slug":"Callback","link":"/tags/Callback/"},{"name":"Bind","slug":"Bind","link":"/tags/Bind/"},{"name":"gRPC-web","slug":"gRPC-web","link":"/tags/gRPC-web/"},{"name":"grpc","slug":"grpc","link":"/tags/grpc/"},{"name":"CI/CD","slug":"CI-CD","link":"/tags/CI-CD/"},{"name":"Gitlab","slug":"Gitlab","link":"/tags/Gitlab/"},{"name":"Pipeline","slug":"Pipeline","link":"/tags/Pipeline/"},{"name":"Mobile","slug":"Mobile","link":"/tags/Mobile/"},{"name":"App Store","slug":"App-Store","link":"/tags/App-Store/"}],"categories":[{"name":"React Native","slug":"React-Native","link":"/categories/React-Native/"},{"name":"AI","slug":"AI","link":"/categories/AI/"},{"name":"system","slug":"system","link":"/categories/system/"},{"name":"React JS","slug":"React-JS","link":"/categories/React-JS/"},{"name":"Javascript","slug":"Javascript","link":"/categories/Javascript/"},{"name":"CSS Magic","slug":"CSS-Magic","link":"/categories/CSS-Magic/"},{"name":"DevOps","slug":"DevOps","link":"/categories/DevOps/"},{"name":"Tuts","slug":"Tuts","link":"/categories/Tuts/"}]}